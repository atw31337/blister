#!/bin/bash
# Blister
# Author: Andrew T. Withers (atw31337@gmail.com)
# Description: This script will download and parse blacklists into ASA configuration format. Commented lines, lines starting with a '#', will be ignored.
# All other lines must either contain a valid IPv4 or IPv6 address (192.168.1.0, fd08:23eb:5a25:7df1:0000:0000:0000:0001), a IPv4 subnet in CIDR notation
# (192.168.1.0/24), or an IPv4 range (192.168.1.0-192.168.1.55). A fqdn function has been added to enable the parsing of URL blacklists. Any URLs containing
# wildcards will be removed because the ASA does not allow them to be used in FQDNs. Lists that follow these formats can be added or removed in the
# "Declare and Parse Blacklists" section. Lists that do not follow these formats will require case specific scripting that can be added to the "Special Cases"
# function section. Feel free to contact me for assistance or Special Case requests.





############################### Config Me #################################################################################
FILEDIR="/opt/blister/"		#Define the directory location of the output file
FILENAME="blister.output"	#Define the name of the output file
BLOCKEDGROUP="BlockedIPs"	#Object group utilized in ACL to block malicious traffic
RECIPIENT=""			#Specify a destination email address if you would like the output emailed to you. Note: Requires mutt and an email server.
RANGEMETHOD=2			#Must be either 1 or 2. Method 1 parses ranges into individual host IPs while method 2 parses ranges into range objects.
###########################################################################################################################

mask() {
#Evaluates CIDR notation and prints the Mask notation equivalent

oct=$(($1 / 8 ))	# First octet that is not equal to 255 (0-3)
mask[0]=255		# First octet must be 255
for (( i=1; i < "$oct"; i++ )); do	# Set octets prior to $oct as 255
	mask["$i"]=255
done
mod=$(( $1 % 8 ))	# Determine the mask value for the first octect that is not equal to 255
if [[ $mod  -gt 0 ]]; then
	expo=$(( 8 - mod ))
	value=$(( 256 - 2**expo ))
	mask["$oct"]="$value"
fi
for (( i=1; i<4; i++ )); do
	if [[ -z ${mask["$i"]} ]]; then	# Set remaining octets to 0
		mask["$i"]=0
	fi
done
echo "${mask[0]}.${mask[1]}.${mask[2]}.${mask[3]}"	# Print the mask
}

check_source() {
if [[ -n $file ]]; then
	if [[ -f $1 ]]; then
		cp "$1" "$TEMP"
	else
		echo "blister: $1 does not exist"
		[[ -f $TEMP ]] && rm "$TEMP"
		[[ -f $fqdn ]] && rm "$fqdn"
		exit 1
	fi
elif [[ $(curl -s -o "$TEMP" -w "%{http_code}" "$1") -eq 200 ]]; then
	:
else
	[[ -f $TEMP ]] && rm -f "$TEMP"
fi
}

fqdn_parse() {  # Parses URL blacklists
# Remove wildcards and URL paths
sed -i '/*/d' "$fqdn" && cut -d '/' -f1 "$fqdn" | sort | uniq > "$TEMP" && rm -f "$fqdn"

while read line; do
	printf "exit\n" >> "$FQFP"
	printf "object network %s\n" "$line" >> "$FQFP"
	printf "fqdn %s\n" "$line" >> "$FQFP"
	printf "object-group network %s\n" "$1" >> "$FQFP"
	printf "network-object object %s\n" "$line" >> "$FQFP"
done < "$TEMP"
}

Parse() {
TEMP="$(mktemp)"	# Temporary file used to store the blacklist that is being processed
fqdn="$(mktemp)"	# Temporary file to store any lines that contain FQDNs

check_source "$1"
if [[ -f $TEMP ]]; then
	# Remove http(s):// if it is present anywhere in the list
	sed -i 's/https\?:\/\///g' "$TEMP"

	# Remove previous version of blacklist object-group and create a new one.
	[[ -z $append ]] && printf "no object-group network %s\n" "$2" >> "$FQFP"
	printf "object-group network %s\n" "$2" >> "$FQFP"
	printf "description Modified: %s\n" "$(date)" >> "$FQFP"

	while read line; do
		if [[ $(echo "$line" | head -c 1) != "#" ]] && [[ -n "$line" ]]; then	#Check for commented and whitespace lines
			if echo "$line" | cut -d '/' -f1 | grep -q '[A-Za-z]'; then	# Separate FQDNs and IPv6 from IPv4
				if echo "$line" | cut -d '/' -f1 | grep -q ':'; then	# IPv6
					if ! grep -q "$(echo $line | cut -d '/' -f1)" "$FQFP"; then	# Check for duplicates
						printf "network-object host %s\n" "$(echo $line | cut -d '/' -f1)" >> "$FQFP"
					fi
				else
					printf "%s\n" "$line" >> "$fqdn"
				fi
			elif echo "$line" | grep -q '[A-Za-z]'; then	# IPv4 address with a path attached
				if ! grep -q "$(echo $line | cut -d '/' -f1)" "$FQFP"; then	# Check for duplicates
					printf "network-object host %s\n" "$(echo $line | cut -d '/' -f1)" >> "$FQFP"
				fi
			# Parse all lines that are in CIDR notation
			elif echo "$line" | grep -q /; then
				CIDR=$(echo "$line" | cut -d'/' -f2)
				IP=$(echo "$line" | cut -d'/' -f1)
				NETMASK=$(mask "$CIDR")
				printf "exit\n"	>> "$FQFP"	#Exit out of object-group in order to create the subnet object.
				printf "object network %s\n" "$IP" >> "$FQFP"
				printf "subnet %s %s\n" "$IP" "$NETMASK" >> "$FQFP"
				printf "object-group network %s\n" "$2" >> "$FQFP"	#Re-enter object-group and add the new subnet object.
				printf "network-object object %s\n" "$IP" >> "$FQFP"
			elif echo "$line" | grep -q -; then
				# Parse all lines containing a range of IP addresses
				BEGINIP=$(echo "$line" | cut -d'-' -f1)	#First IP in the range
				ENDIP=$(echo "$line" | cut -d'-' -f2)		#Last IP in the range
				OCT1=$(echo "$BEGINIP" | cut -d'.' -f1)	#First octect of starting IP
				OCT2=$(echo "$BEGINIP" | cut -d'.' -f2)	#Second octect of starting IP
				OCT3=$(echo "$BEGINIP" | cut -d'.' -f3)	#Third octect of starting IP
				OCT4=$(echo "$BEGINIP" | cut -d'.' -f4)	#Fourth octect of starting IP

				##Method 1: Parse ranges into individual host IPs
				if [[ $RANGEMETHOD -eq 1 ]]; then
					IP="$BEGINIP"
					printf "network-object host %s\n" "$BEGINIP" >> "$FQFP"

					while [[ $IP != $ENDIP ]]; do
						if [[ $OCT4 -eq 255 ]]; then
							OCT4=0
							if [[ $OCT3 -eq 255 ]]; then
								OCT3=0
								if [[ $OCT2 -eq 255 ]]; then
									OCT2=0
									((OCT1+=1))
								else
									((OCT2+=1))
								fi
							else
								((OCT3+=1))
							fi
						else
							((OCT4+=1))
						fi
						IP="$OCT1.$OCT2.$OCT3.$OCT4"
						printf "network-object host %s\n" "$IP" >> "$FQFP"
					done

				elif [[ $RANGEMETHOD -eq 2 ]]; then	##Method 2: Create IP range objects
					((OCT4+=1))
					IP="$OCT1.$OCT2.$OCT3.$OCT4"
					if [[ "$IP" == "$ENDIP" ]]; then	#Test for ranges containing only 2 IP addresses
						printf "network-object host %s\n" "$BEGINIP" >> "$FQFP"
						printf "network-object host %s\n" "$ENDIP" >> "$FQFP"
					else
						printf "exit\n" >> "$FQFP"	#Exit out of the object-group in order to create the range object.
						printf "object network %s\n" "$BEGINIP" >> "$FQFP"
						printf "range %s %s\n" "$BEGINIP" "$ENDIP" >> "$FQFP"
						printf "object-group network %s\n" "$2" >> "$FQFP"	#Re-enter the object-group in order to add the new range object.
						printf "network-object object %s\n" "$BEGINIP" >> "$FQFP"
					fi
				else
					(>&2 printf "Error: Failed to parse range IPs. RANGEMETHOD has been improperly configured.\n\n")
				fi
			else	#Part 3: Parse remaining lines
				printf "network-object host %s\n" "$line" >> "$FQFP"
			fi
		fi
	done < "$TEMP"

	# Process FQDNs
	if [[ -s "$fqdn" ]]; then
		fqdn_parse "$2"
	fi

	if [[ -z $append ]]; then
		#Add blacklist object-group to the Blocked object-group
		printf "object-group network %s\n" "$BLOCKEDGROUP" >> "$FQFP"
		printf "group-object %s\n" "$2" >> "$FQFP"
	fi

	#Exit object-group
	printf "exit\n" >> "$FQFP"
else
	echo "Invalid URL: $1"
	echo Skipping blacklist
	printf "%s Invalid URL: %s\n" "$(date)" "$1" >> /var/log/blister.log
fi

# Remove temporary files
[[ -f $TEMP ]] && rm -f "$TEMP"
[[ -f $fqdn ]] && rm -f "$fqdn"
}

################################# Special Cases #######################################

dshield_parse() {	#DShield Block List
DSHIELD="$(mktemp)"
TEMP="$(mktemp)"	#Temporary file used to store the blacklist that is being processed

if [[ $(curl -s -o "$TEMP" -w "%{http_code}" https://www.dshield.org/block.txt) -eq 200 ]]; then
	tail -n +30 "$TEMP" > "$DSHIELD"
	awk '{ print $1"/"$3 }' "$DSHIELD" > "$TEMP"
	rm -f "$DSHIELD"

	#Remove previous version of blacklist object-group and create a new one.
	[[ -z $append ]] && printf "no object-group network DShield_Block_List\n" >> "$FQFP"
	printf "object-group network DShield_Block_List\n" >> "$FQFP"
	printf "description Modified: %s\n" "$(date)" >> "$FQFP"

	while read line; do
		if [[ $(echo "$line" | head -c 1) != "#" ]] && [[ -n "$line" ]] ; then    #Check for commented and whitespace lines
			CIDR=$(echo "$line" | cut -d'/' -f2)
			IP=$(echo "$line" | cut -d'/' -f1)
			NETMASK=$(mask "$CIDR")
			printf "exit\n" >> "$FQFP"
			printf "object network %s\n" "$IP" >> "$FQFP"
			printf "subnet %s %s\n" "$IP" "$NETMASK" >> "$FQFP"
			printf "object-group network DShield_Block_List\n" >> "$FQFP"
			printf "network-object object %s\n" "$IP" >> "$FQFP"
		fi
	done < "$TEMP"

	if [[ -z $append ]]; then
		#Add blacklist object-group to the Blocked object-group
		printf "object-group network %s\n" "$BLOCKEDGROUP" >> "$FQFP"
		printf "group-object DShield_Block_List\n" >> "$FQFP"
	fi

	##Exit object-group
	printf "exit\n" >> "$FQFP"
else
	echo Invalid URL: https://www.dshield.org/block.txt
	echo Skipping blacklist
	printf "Invalid URL: https://www.dshield.org/block.txt\n" >> /var/log/blister.log
fi

# Remove temporary blacklist file
[[ -f $TEMP ]] && rm -f "$TEMP"
}

usage() {
cat <<EOF

Blister - Blacklist to ASA Command Parsing Script
Usage: blister [OPTION]

	Options:
		-h		Usage
		-a		Send output as an email attachment
		-A		Appends list(s) instead of replacing
		-f <FILE>	Parses a single list from a local file
		-o <FILE>	Specifies the name of the output file

EOF
}

# Parse options
while getopts ":haAf:o:" OPT; do
	case "$OPT" in
		h)
			usage
			exit 0
			;;
		a)
			attach=1
			;;
		A)
			append=1
			;;
		f)
			file=1
			SOURCE="$OPTARG"
			;;
		o)
			FILENAME="$OPTARG"
			;;
		:)
			echo "Invalid option: $OPTARG requires an argument"
			usage
			exit 0
			;;
		\?)
			echo "Invalid option: $OPTARG"
			usage
			exit 0
			;;
	esac
done

# Check if another instance of blister is running before proceeding.
if [[ $(pgrep -c blister) -gt 1 ]]; then
        echo "One or more instances of blister are already running."
	echo "The integrity of the output will be compromised if multiple instances use the same output filename."
	read -p "Do you want to continue? [y/N]: " answer
	if [[ ${answer,,} == 'y' ]]; then
		:
	else
		exit 0
	fi
fi

# Remove previous log file
[[ -e /var/log/blister.log ]] && rm /var/log/blister.log

###################################### Set File Locations and Enter Config Mode ##########################################

FQFP="$FILEDIR$FILENAME"		#Fully Qualified File Path of output file

if ! [[ -d $FILEDIR ]]; then
	mkdir -pm 664 "$FILEDIR"
fi

printf "config t\n" > "$FQFP"

################################################# Single List Local File ##################################################

if [[ -n $file ]]; then
	while [[ -z $OBJECTGROUP ]]; do
		read -p "Please enter an object group name for this list: " OBJECTGROUP
		if [[ -z $OBJECTGROUP ]]; then
			echo "An object group name is required"
		fi
	done
	Parse "$SOURCE" "$OBJECTGROUP"
else

##################### Declare and Parse Blacklists ######################

#Spamhaus Drop List
URL="https://panwdbl.appspot.com/lists/shdrop.txt"
OBJECTGROUP="SpamhausDropList"

Parse "$URL" "$OBJECTGROUP"

#CINS Active Threats Intelligence
URL="http://cinsscore.com/list/ci-badguys.txt"
OBJECTGROUP="CINS_ActiveThreats"

Parse "$URL" "$OBJECTGROUP"

#Tor Network	Note: This blacklist can only be downloaded once every 30 minutes.
URL="https://www.dan.me.uk/torlist/"
OBJECTGROUP="Tor_Network"

Parse "$URL" "$OBJECTGROUP"

#ET Known Compromised or Hostile Traffic Hosts
URL="https://rules.emergingthreats.net/blockrules/compromised-ips.txt"
OBJECTGROUP="ETKnownCompromised"

Parse "$URL" "$OBJECTGROUP"

#Ransomeware Tracker CnC Servers
URL="https://ransomwaretracker.abuse.ch/downloads/RW_IPBL.txt"
OBJECTGROUP="RansomwareCnC"

Parse "$URL" "$OBJECTGROUP"

## Zues Tracker was dicontinued on Jul 8th, 2019
# Zeus Tracker CnC Servers
# URL="https://zeustracker.abuse.ch/blocklist.php?download=badips"
# OBJECTGROUP="ZeusTracker"
# Parse "$URL" "$OBJECTGROUP"

#Malware Domain List
URL="https://panwdbl.appspot.com/lists/mdl.txt"
OBJECTGROUP="MalwareDomainList"

Parse "$URL" "$OBJECTGROUP"

#Brute Force Blocker
URL="https://panwdbl.appspot.com/lists/bruteforceblocker.txt"
OBJECTGROUP="BruteForceBlocker"

Parse "$URL" "$OBJECTGROUP"

#SSL Abuse List
URL="https://panwdbl.appspot.com/lists/sslabuseiplist.txt"
OBJECTGROUP="SSLAbuseList"

Parse "$URL" "$OBJECTGROUP"

#Feodo Tracker CnC Servers
URL="https://feodotracker.abuse.ch/downloads/ipblocklist.txt"
OBJECTGROUP="FeodoTracker"

Parse "$URL" "$OBJECTGROUP"

#DShield Block List
dshield_parse

# Caution: May cause legitimate sites on the same host to be blocked
# Openphish phishing list
# URL="https://openphish.com/feed.txt"
# OBJECTGROUP="OpenPhish"

# Parse "$URL" "$OBJECTGROUP"

fi

##Exit config t
printf "exit\n\n" >> "$FQFP"

################################## Email Output ########################################
if [[ -n "$RECIPIENT" ]]; then	#Check if an email address has been configured
	if [[ -n $attach ]]; then
		echo "Blister output" | EMAIL="Blister" mutt -a "$FQFP" -s "ASA Blacklist Config" -- "$RECIPIENT"
	else
		cat "$FQFP" | EMAIL="Blister" mutt -s "ASA Blacklist Config" -- "$RECIPIENT"
	fi
fi

exit
